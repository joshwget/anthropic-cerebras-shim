import { describe, it, expect, beforeAll, afterAll, beforeEach, afterEach } from "vitest";
import { query, type SDKMessage } from "@anthropic-ai/claude-agent-sdk";
import { createServer } from "../src/server.js";
import type { Express } from "express";
import http from "http";
import fs from "fs/promises";
import path from "path";
import os from "os";
import "dotenv/config";

const CEREBRAS_API_KEY = process.env.CEREBRAS_API_KEY;

/**
 * Helper to collect all messages from a query and extract final result
 */
async function runAgent(
  prompt: string,
  options: Parameters<typeof query>[0]["options"] = {}
): Promise<{
  messages: SDKMessage[];
  result: string | null;
  sessionId: string | null;
}> {
  const messages: SDKMessage[] = [];
  let result: string | null = null;
  let sessionId: string | null = null;

  for await (const message of query({ prompt, options })) {
    messages.push(message);

    if (message.type === "system" && message.subtype === "init") {
      sessionId = message.session_id ?? null;
    }

    if (message.type === "result") {
      result = message.result ?? null;
    }
  }

  return { messages, result, sessionId };
}

/**
 * Helper to check if agent completed successfully
 */
function wasSuccessful(messages: SDKMessage[]): boolean {
  const resultMessage = messages.find((m) => m.type === "result");
  return resultMessage?.subtype === "success";
}

/**
 * Helper to extract assistant text responses
 */
function getAssistantTexts(messages: SDKMessage[]): string[] {
  const texts: string[] = [];
  for (const message of messages) {
    if (message.type === "assistant" && message.message?.content) {
      for (const block of message.message.content) {
        if ("text" in block && block.text) {
          texts.push(block.text);
        }
      }
    }
  }
  return texts;
}

/**
 * Helper to extract tool calls made
 */
function getToolCalls(messages: SDKMessage[]): string[] {
  const tools: string[] = [];
  for (const message of messages) {
    if (message.type === "assistant" && message.message?.content) {
      for (const block of message.message.content) {
        if ("name" in block && block.name) {
          tools.push(block.name);
        }
      }
    }
  }
  return tools;
}

describe.skipIf(!CEREBRAS_API_KEY)("Claude Agent SDK Integration Tests", () => {
  let app: Express;
  let server: http.Server;
  let baseUrl: string;
  let tempDir: string;
  let originalEnv: NodeJS.ProcessEnv;

  beforeAll(async () => {
    // Save original env
    originalEnv = { ...process.env };

    // Start shim server
    app = createServer({ cerebrasApiKey: CEREBRAS_API_KEY! });
    server = app.listen(0);
    const address = server.address();
    if (typeof address === "object" && address !== null) {
      baseUrl = `http://localhost:${address.port}`;
    }

    // Configure Claude Agent SDK to use our shim
    process.env.ANTHROPIC_BASE_URL = baseUrl;
    // The SDK should use CEREBRAS_API_KEY through the shim - but needs some key
    process.env.ANTHROPIC_API_KEY = "shim-passthrough";
  });

  afterAll(() => {
    server.close();
    // Restore original env
    process.env = originalEnv;
  });

  beforeEach(async () => {
    // Create temp directory for each test
    tempDir = await fs.mkdtemp(path.join(os.tmpdir(), "agent-sdk-test-"));
  });

  afterEach(async () => {
    // Cleanup temp directory
    try {
      await fs.rm(tempDir, { recursive: true, force: true });
    } catch {
      // Ignore cleanup errors
    }
  });

  describe("Basic Agent Operations", () => {
    it("should complete a simple file reading task", async () => {
      // Create a test file
      const testFile = path.join(tempDir, "hello.txt");
      await fs.writeFile(testFile, "Hello from the test file!");

      const { messages, result } = await runAgent(
        `Read the file at ${testFile} and tell me what it contains. Be concise.`,
        {
          allowedTools: ["Read"],
          permissionMode: "bypassPermissions",
          cwd: tempDir,
          maxTurns: 5,
        }
      );

      expect(wasSuccessful(messages)).toBe(true);
      const toolCalls = getToolCalls(messages);
      expect(toolCalls).toContain("Read");
      const texts = getAssistantTexts(messages);
      const combinedText = texts.join(" ").toLowerCase();
      expect(combinedText).toContain("hello");
    }, 120000);

    it("should create a new file with content", async () => {
      const targetFile = path.join(tempDir, "output.txt");

      const { messages } = await runAgent(
        `Create a file at ${targetFile} with the content "Generated by Claude Agent". Then confirm the file was created.`,
        {
          allowedTools: ["Write", "Read"],
          permissionMode: "bypassPermissions",
          cwd: tempDir,
          maxTurns: 5,
        }
      );

      expect(wasSuccessful(messages)).toBe(true);

      // Verify file was created
      const content = await fs.readFile(targetFile, "utf-8");
      expect(content).toContain("Generated by Claude Agent");
    }, 120000);

    it("should run a shell command", async () => {
      const { messages } = await runAgent(
        `Run "echo 'Agent test successful'" in the shell and report the output.`,
        {
          allowedTools: ["Bash"],
          permissionMode: "bypassPermissions",
          cwd: tempDir,
          maxTurns: 5,
        }
      );

      expect(wasSuccessful(messages)).toBe(true);
      const toolCalls = getToolCalls(messages);
      expect(toolCalls).toContain("Bash");
    }, 120000);
  });

  describe("Complex Coding Tasks", () => {
    it("should write and then modify a Python function", async () => {
      const codeFile = path.join(tempDir, "calculator.py");

      // Step 1: Have the agent write a calculator function
      const { messages: createMessages } = await runAgent(
        `Write a Python file at ${codeFile} that contains a function called 'calculate' that takes two numbers and an operator (+, -, *, /) and returns the result. Include error handling for division by zero.`,
        {
          allowedTools: ["Write", "Read"],
          permissionMode: "bypassPermissions",
          cwd: tempDir,
          maxTurns: 8,
        }
      );

      expect(wasSuccessful(createMessages)).toBe(true);

      // Verify file exists
      const content = await fs.readFile(codeFile, "utf-8");
      expect(content).toContain("def calculate");
      // Should handle division by zero
      expect(
        content.toLowerCase().includes("division") ||
        content.toLowerCase().includes("divide") ||
        content.toLowerCase().includes("zero")
      ).toBe(true);
    }, 180000);

    it("should write a TypeScript utility function with types", async () => {
      const codeFile = path.join(tempDir, "utils.ts");

      const { messages } = await runAgent(
        `Write a TypeScript file at ${codeFile} with a function called 'deepMerge' that recursively merges two objects. Include proper TypeScript generic types. The function should handle nested objects and arrays.`,
        {
          allowedTools: ["Write", "Read"],
          permissionMode: "bypassPermissions",
          cwd: tempDir,
          maxTurns: 8,
        }
      );

      expect(wasSuccessful(messages)).toBe(true);

      const content = await fs.readFile(codeFile, "utf-8");
      expect(content).toContain("deepMerge");
      expect(content).toMatch(/<.*>/); // Has generic type syntax
    }, 180000);

    it("should analyze code and suggest improvements", async () => {
      // Create a file with intentionally improvable code
      const codeFile = path.join(tempDir, "legacy.js");
      await fs.writeFile(
        codeFile,
        `
function getData(url, callback) {
  var xhr = new XMLHttpRequest();
  xhr.open('GET', url);
  xhr.onload = function() {
    if (xhr.status == 200) {
      callback(null, JSON.parse(xhr.responseText));
    } else {
      callback('Error: ' + xhr.status);
    }
  };
  xhr.send();
}

function processItems(items) {
  var result = [];
  for (var i = 0; i < items.length; i++) {
    if (items[i].active == true) {
      result.push(items[i].name);
    }
  }
  return result;
}
`
      );

      const { messages } = await runAgent(
        `Read the JavaScript file at ${codeFile} and analyze it. List 3 specific improvements that could be made to modernize this code. Be concise with your suggestions.`,
        {
          allowedTools: ["Read"],
          permissionMode: "bypassPermissions",
          cwd: tempDir,
          maxTurns: 5,
        }
      );

      expect(wasSuccessful(messages)).toBe(true);
      const texts = getAssistantTexts(messages);
      const combinedText = texts.join(" ").toLowerCase();

      // Should mention modern improvements
      expect(
        combinedText.includes("async") ||
          combinedText.includes("await") ||
          combinedText.includes("fetch") ||
          combinedText.includes("const") ||
          combinedText.includes("let") ||
          combinedText.includes("arrow") ||
          combinedText.includes("===") ||
          combinedText.includes("modern")
      ).toBe(true);
    }, 120000);

    it("should implement a multi-file refactoring", async () => {
      // Create initial files
      const mainFile = path.join(tempDir, "main.js");
      const configFile = path.join(tempDir, "config.js");

      await fs.writeFile(
        mainFile,
        `
const API_URL = "https://api.example.com";
const API_KEY = "abc123";
const TIMEOUT = 5000;

function fetchData() {
  console.log("Fetching from " + API_URL);
}
`
      );

      const { messages } = await runAgent(
        `I have a file at ${mainFile}. Please:
1. Read it to understand the current structure
2. Create a new config file at ${configFile} and move all the constants (API_URL, API_KEY, TIMEOUT) there as exports
3. Update ${mainFile} to import from the config file

Use ES module syntax (import/export).`,
        {
          allowedTools: ["Read", "Write", "Edit"],
          permissionMode: "bypassPermissions",
          cwd: tempDir,
          maxTurns: 12,
        }
      );

      expect(wasSuccessful(messages)).toBe(true);

      // Verify config file was created with exports
      const configContent = await fs.readFile(configFile, "utf-8");
      expect(configContent).toMatch(/export/);
      expect(configContent).toContain("API_URL");

      // Verify main file imports from config
      const mainContent = await fs.readFile(mainFile, "utf-8");
      expect(mainContent).toMatch(/import.*config/i);
    }, 180000);
  });

  describe("Data Analysis Tasks", () => {
    it("should analyze JSON data and extract statistics", async () => {
      const dataFile = path.join(tempDir, "sales.json");
      const salesData = {
        sales: [
          { id: 1, product: "Widget A", amount: 100, date: "2024-01-15" },
          { id: 2, product: "Widget B", amount: 250, date: "2024-01-16" },
          { id: 3, product: "Widget A", amount: 150, date: "2024-01-17" },
          { id: 4, product: "Widget C", amount: 75, date: "2024-01-18" },
          { id: 5, product: "Widget B", amount: 300, date: "2024-01-19" },
          { id: 6, product: "Widget A", amount: 200, date: "2024-01-20" },
        ],
      };
      await fs.writeFile(dataFile, JSON.stringify(salesData, null, 2));

      const { messages } = await runAgent(
        `Read the JSON file at ${dataFile} and analyze the sales data. Calculate:
1. Total sales amount
2. Average sale amount
3. Which product has the highest total sales
Be concise and provide the numbers.`,
        {
          allowedTools: ["Read"],
          permissionMode: "bypassPermissions",
          cwd: tempDir,
          maxTurns: 5,
        }
      );

      expect(wasSuccessful(messages)).toBe(true);
      const texts = getAssistantTexts(messages);
      const combinedText = texts.join(" ");

      // Check for reasonable analysis - allow different number formats
      expect(
        combinedText.includes("1075") ||
        combinedText.includes("1,075") ||
        combinedText.includes("$1,075") ||
        combinedText.includes("$1075")
      ).toBe(true);
      expect(combinedText.toLowerCase()).toContain("widget");
    }, 120000);

    it("should process CSV-like data", async () => {
      const dataFile = path.join(tempDir, "users.csv");
      await fs.writeFile(
        dataFile,
        `name,email,age,country
Alice Smith,alice@example.com,28,USA
Bob Johnson,bob@example.com,35,Canada
Carol Williams,carol@example.com,42,UK
David Brown,david@example.com,31,USA
Eve Davis,eve@example.com,27,Canada
Frank Miller,frank@example.com,45,USA`
      );

      const { messages } = await runAgent(
        `Read the CSV file at ${dataFile} and tell me:
1. How many users are from USA?
2. What is the average age?
3. List all unique countries.
Be concise with your answers.`,
        {
          allowedTools: ["Read"],
          permissionMode: "bypassPermissions",
          cwd: tempDir,
          maxTurns: 5,
        }
      );

      expect(wasSuccessful(messages)).toBe(true);
      const texts = getAssistantTexts(messages);
      const combinedText = texts.join(" ").toLowerCase();

      // Verify USA count (3 users)
      expect(combinedText).toContain("3");
      // Check countries are mentioned
      expect(combinedText).toContain("usa");
      expect(combinedText).toContain("canada");
      expect(combinedText).toContain("uk");
    }, 120000);

    it("should generate a summary report from multiple files", async () => {
      // Create multiple data files
      await fs.writeFile(
        path.join(tempDir, "q1.json"),
        JSON.stringify({ quarter: "Q1", revenue: 10000, expenses: 7500 })
      );
      await fs.writeFile(
        path.join(tempDir, "q2.json"),
        JSON.stringify({ quarter: "Q2", revenue: 12000, expenses: 8000 })
      );
      await fs.writeFile(
        path.join(tempDir, "q3.json"),
        JSON.stringify({ quarter: "Q3", revenue: 15000, expenses: 9500 })
      );

      const reportFile = path.join(tempDir, "report.md");

      const { messages } = await runAgent(
        `Read all JSON files in ${tempDir} (q1.json, q2.json, q3.json) that contain quarterly financial data. Create a markdown summary report at ${reportFile} that includes:
1. Total revenue across all quarters
2. Total expenses across all quarters
3. Overall profit
4. The best performing quarter by profit margin`,
        {
          allowedTools: ["Read", "Write", "Glob"],
          permissionMode: "bypassPermissions",
          cwd: tempDir,
          maxTurns: 10,
        }
      );

      expect(wasSuccessful(messages)).toBe(true);

      const reportContent = await fs.readFile(reportFile, "utf-8");
      // Total revenue: 37000 - allow different formats
      expect(
        reportContent.includes("37000") ||
        reportContent.includes("37,000") ||
        reportContent.includes("$37,000") ||
        reportContent.includes("$37000")
      ).toBe(true);
      // Should mention quarters
      expect(reportContent.toLowerCase()).toMatch(/q[123]/);
    }, 180000);
  });

  describe("Search and Discovery Tasks", () => {
    it("should find files matching a pattern", async () => {
      // Create test file structure
      await fs.mkdir(path.join(tempDir, "src"), { recursive: true });
      await fs.mkdir(path.join(tempDir, "tests"), { recursive: true });
      await fs.writeFile(path.join(tempDir, "src", "app.ts"), "// app");
      await fs.writeFile(path.join(tempDir, "src", "utils.ts"), "// utils");
      await fs.writeFile(path.join(tempDir, "src", "index.js"), "// index");
      await fs.writeFile(path.join(tempDir, "tests", "app.test.ts"), "// test");

      const { messages } = await runAgent(
        `Find all TypeScript files (*.ts) in ${tempDir} and list them. Tell me how many you found.`,
        {
          allowedTools: ["Glob", "Read"],
          permissionMode: "bypassPermissions",
          cwd: tempDir,
          maxTurns: 5,
        }
      );

      expect(wasSuccessful(messages)).toBe(true);
      const toolCalls = getToolCalls(messages);
      expect(toolCalls).toContain("Glob");

      const texts = getAssistantTexts(messages);
      const combinedText = texts.join(" ").toLowerCase();
      // Should find 3 .ts files
      expect(combinedText).toContain("3");
    }, 120000);

    it("should search file contents with grep", async () => {
      await fs.mkdir(path.join(tempDir, "src"), { recursive: true });
      await fs.writeFile(
        path.join(tempDir, "src", "api.ts"),
        `
export function fetchUsers() {
  // TODO: implement caching
  return fetch('/api/users');
}

export function fetchProducts() {
  // TODO: add pagination
  return fetch('/api/products');
}
`
      );
      await fs.writeFile(
        path.join(tempDir, "src", "utils.ts"),
        `
export function formatDate(date: Date) {
  // TODO: support localization
  return date.toISOString();
}
`
      );

      const { messages } = await runAgent(
        `Search for all TODO comments in the TypeScript files in ${tempDir}. List each TODO and which file it's in.`,
        {
          allowedTools: ["Grep", "Glob", "Read"],
          permissionMode: "bypassPermissions",
          cwd: tempDir,
          maxTurns: 8,
        }
      );

      expect(wasSuccessful(messages)).toBe(true);
      const toolCalls = getToolCalls(messages);
      expect(toolCalls.includes("Grep") || toolCalls.includes("Read")).toBe(true);

      const texts = getAssistantTexts(messages);
      const combinedText = texts.join(" ").toLowerCase();
      // Should find TODOs about caching, pagination, localization
      expect(
        combinedText.includes("caching") ||
          combinedText.includes("pagination") ||
          combinedText.includes("localization") ||
          combinedText.includes("todo")
      ).toBe(true);
    }, 120000);
  });

  describe("Multi-Step Complex Tasks", () => {
    it("should complete a project scaffolding task", async () => {
      const projectDir = path.join(tempDir, "my-project");

      const { messages } = await runAgent(
        `Create a basic Node.js project structure at ${projectDir}:
1. Create package.json with name "my-project" and version "1.0.0"
2. Create src/index.ts with a main function that logs "Hello World"
3. Create a README.md with a title and brief description

Create all directories as needed.`,
        {
          allowedTools: ["Write", "Bash"],
          permissionMode: "bypassPermissions",
          cwd: tempDir,
          maxTurns: 12,
        }
      );

      expect(wasSuccessful(messages)).toBe(true);

      // Verify structure
      const packageJson = JSON.parse(
        await fs.readFile(path.join(projectDir, "package.json"), "utf-8")
      );
      expect(packageJson.name).toBe("my-project");

      const indexTs = await fs.readFile(path.join(projectDir, "src", "index.ts"), "utf-8");
      expect(indexTs.toLowerCase()).toContain("hello");

      const readme = await fs.readFile(path.join(projectDir, "README.md"), "utf-8");
      expect(readme.length).toBeGreaterThan(0);
    }, 240000);

    it("should debug and fix a broken script", async () => {
      // Create a file with a deliberate bug
      const scriptFile = path.join(tempDir, "broken.js");
      await fs.writeFile(
        scriptFile,
        `
// This script has a bug - it should sum an array
function sumArray(arr) {
  let total = 0;
  for (let i = 0; i <= arr.length; i++) {  // Bug: should be < not <=
    total += arr[i];
  }
  return total;
}

console.log(sumArray([1, 2, 3, 4, 5]));  // Should print 15, but has bug
`
      );

      const { messages } = await runAgent(
        `Read the JavaScript file at ${scriptFile}. It has a bug - find and fix it. The function should correctly sum all numbers in an array.`,
        {
          allowedTools: ["Read", "Edit"],
          permissionMode: "bypassPermissions",
          cwd: tempDir,
          maxTurns: 8,
        }
      );

      expect(wasSuccessful(messages)).toBe(true);

      // Verify the bug was fixed
      const fixedContent = await fs.readFile(scriptFile, "utf-8");
      // Should have fixed the loop condition
      expect(fixedContent).toContain("< arr.length");
    }, 180000);
  });

  describe("Generalized File I/O Coding Tasks", () => {
    it("should read a file, transform content, and write to new file", async () => {
      // Create source file with raw data
      const sourceFile = path.join(tempDir, "raw-data.txt");
      await fs.writeFile(
        sourceFile,
        `john,doe,25
jane,smith,30
bob,wilson,22
alice,jones,28`
      );

      const outputFile = path.join(tempDir, "formatted-data.json");

      const { messages } = await runAgent(
        `Read the CSV data from ${sourceFile} where each line has firstname,lastname,age.
Transform this data into a JSON array of objects with keys "firstName", "lastName", and "age" (as a number).
Write the result to ${outputFile}.`,
        {
          allowedTools: ["Read", "Write"],
          permissionMode: "bypassPermissions",
          cwd: tempDir,
          maxTurns: 8,
        }
      );

      expect(wasSuccessful(messages)).toBe(true);

      // Verify output file
      const outputContent = await fs.readFile(outputFile, "utf-8");
      const parsed = JSON.parse(outputContent);
      expect(Array.isArray(parsed)).toBe(true);
      expect(parsed.length).toBe(4);
      expect(parsed[0]).toHaveProperty("firstName");
      expect(parsed[0]).toHaveProperty("lastName");
      expect(parsed[0]).toHaveProperty("age");
    }, 180000);

    it("should create a utility module and a file that uses it", async () => {
      const utilsFile = path.join(tempDir, "string-utils.ts");
      const mainFile = path.join(tempDir, "main.ts");

      const { messages } = await runAgent(
        `Create two TypeScript files:
1. ${utilsFile}: Create a module with exported functions: capitalize(str), reverse(str), and isPalindrome(str)
2. ${mainFile}: Import all functions from string-utils.ts and use each one with example strings, logging results

Make sure main.ts properly imports from the relative path ./string-utils`,
        {
          allowedTools: ["Write", "Read"],
          permissionMode: "bypassPermissions",
          cwd: tempDir,
          maxTurns: 10,
        }
      );

      expect(wasSuccessful(messages)).toBe(true);

      // Verify utils file
      const utilsContent = await fs.readFile(utilsFile, "utf-8");
      expect(utilsContent).toContain("export");
      expect(utilsContent).toContain("capitalize");
      expect(utilsContent).toContain("reverse");
      expect(utilsContent).toContain("isPalindrome");

      // Verify main file imports utils
      const mainContent = await fs.readFile(mainFile, "utf-8");
      expect(mainContent).toMatch(/import.*string-utils/);
    }, 180000);

    it("should iteratively build a configuration file", async () => {
      const configFile = path.join(tempDir, "app-config.json");

      // Step 1: Create initial config
      const { messages: step1 } = await runAgent(
        `Create a JSON config file at ${configFile} with an initial structure:
{
  "appName": "MyApp",
  "version": "1.0.0",
  "settings": {}
}`,
        {
          allowedTools: ["Write"],
          permissionMode: "bypassPermissions",
          cwd: tempDir,
          maxTurns: 5,
        }
      );
      expect(wasSuccessful(step1)).toBe(true);

      // Step 2: Add database settings
      const { messages: step2 } = await runAgent(
        `Read the config file at ${configFile} and add a "database" section inside "settings" with host: "localhost", port: 5432, name: "myapp_db". Keep all existing content.`,
        {
          allowedTools: ["Read", "Edit", "Write"],
          permissionMode: "bypassPermissions",
          cwd: tempDir,
          maxTurns: 8,
        }
      );
      expect(wasSuccessful(step2)).toBe(true);

      // Step 3: Add logging settings
      const { messages: step3 } = await runAgent(
        `Read the config file at ${configFile} and add a "logging" section inside "settings" with level: "info", format: "json". Keep all existing content including the database settings.`,
        {
          allowedTools: ["Read", "Edit", "Write"],
          permissionMode: "bypassPermissions",
          cwd: tempDir,
          maxTurns: 8,
        }
      );
      expect(wasSuccessful(step3)).toBe(true);

      // Verify final config
      const finalConfig = JSON.parse(await fs.readFile(configFile, "utf-8"));
      expect(finalConfig.appName).toBe("MyApp");
      expect(finalConfig.settings.database).toBeDefined();
      expect(finalConfig.settings.database.host).toBe("localhost");
      expect(finalConfig.settings.logging).toBeDefined();
      expect(finalConfig.settings.logging.level).toBe("info");
    }, 300000);

    it("should generate code from a specification file", async () => {
      // Create a specification file
      const specFile = path.join(tempDir, "api-spec.json");
      await fs.writeFile(
        specFile,
        JSON.stringify({
          entity: "User",
          fields: [
            { name: "id", type: "number" },
            { name: "name", type: "string" },
            { name: "email", type: "string" },
            { name: "isActive", type: "boolean" },
          ],
        }, null, 2)
      );

      const outputFile = path.join(tempDir, "user.ts");

      const { messages } = await runAgent(
        `Read the API specification from ${specFile}. Based on the entity name and fields defined, generate a TypeScript file at ${outputFile} containing:
1. An interface for the entity (e.g., interface User)
2. A type guard function (e.g., isUser(obj): obj is User)
3. A factory function to create instances (e.g., createUser(data): User)`,
        {
          allowedTools: ["Read", "Write"],
          permissionMode: "bypassPermissions",
          cwd: tempDir,
          maxTurns: 10,
        }
      );

      expect(wasSuccessful(messages)).toBe(true);

      const outputContent = await fs.readFile(outputFile, "utf-8");
      expect(outputContent).toContain("interface User");
      expect(outputContent).toMatch(/isUser|is\s*User/);
      expect(outputContent).toMatch(/createUser|create\s*User/);
      expect(outputContent).toContain("id");
      expect(outputContent).toContain("name");
      expect(outputContent).toContain("email");
    }, 180000);

    it("should read source code and generate corresponding tests", async () => {
      // Create source file to generate tests for
      const sourceFile = path.join(tempDir, "math-utils.ts");
      await fs.writeFile(
        sourceFile,
        `export function add(a: number, b: number): number {
  return a + b;
}

export function multiply(a: number, b: number): number {
  return a * b;
}

export function divide(a: number, b: number): number {
  if (b === 0) throw new Error("Cannot divide by zero");
  return a / b;
}

export function factorial(n: number): number {
  if (n < 0) throw new Error("Negative numbers not allowed");
  if (n <= 1) return 1;
  return n * factorial(n - 1);
}
`
      );

      const testFile = path.join(tempDir, "math-utils.test.ts");

      const { messages } = await runAgent(
        `Read the source file at ${sourceFile} and generate a test file at ${testFile} that tests all the exported functions. Include tests for:
- Normal cases for each function
- Edge cases (like division by zero, factorial of 0)
- Use simple test structure with describe/it blocks (just mock the structure, don't import from a test framework)`,
        {
          allowedTools: ["Read", "Write"],
          permissionMode: "bypassPermissions",
          cwd: tempDir,
          maxTurns: 10,
        }
      );

      expect(wasSuccessful(messages)).toBe(true);

      const testContent = await fs.readFile(testFile, "utf-8");
      expect(testContent).toContain("add");
      expect(testContent).toContain("multiply");
      expect(testContent).toContain("divide");
      expect(testContent).toContain("factorial");
      // Should test edge cases
      expect(
        testContent.includes("zero") ||
        testContent.includes("0") ||
        testContent.includes("edge") ||
        testContent.includes("error") ||
        testContent.includes("throw")
      ).toBe(true);
    }, 180000);

    it("should process multiple input files and create a merged output", async () => {
      // Create multiple config fragments
      await fs.writeFile(
        path.join(tempDir, "db-config.json"),
        JSON.stringify({ database: { host: "db.example.com", port: 5432 } })
      );
      await fs.writeFile(
        path.join(tempDir, "cache-config.json"),
        JSON.stringify({ cache: { type: "redis", host: "redis.example.com" } })
      );
      await fs.writeFile(
        path.join(tempDir, "auth-config.json"),
        JSON.stringify({ auth: { provider: "oauth", clientId: "abc123" } })
      );

      const mergedFile = path.join(tempDir, "merged-config.json");

      const { messages } = await runAgent(
        `Read all three config files in ${tempDir}: db-config.json, cache-config.json, and auth-config.json.
Merge them into a single configuration object and write to ${mergedFile}.
The merged config should have all three sections: database, cache, and auth.`,
        {
          allowedTools: ["Read", "Write", "Glob"],
          permissionMode: "bypassPermissions",
          cwd: tempDir,
          maxTurns: 12,
        }
      );

      expect(wasSuccessful(messages)).toBe(true);

      const mergedContent = JSON.parse(await fs.readFile(mergedFile, "utf-8"));
      expect(mergedContent.database).toBeDefined();
      expect(mergedContent.database.host).toBe("db.example.com");
      expect(mergedContent.cache).toBeDefined();
      expect(mergedContent.cache.type).toBe("redis");
      expect(mergedContent.auth).toBeDefined();
      expect(mergedContent.auth.provider).toBe("oauth");
    }, 180000);

    it("should refactor code by extracting functions", async () => {
      const sourceFile = path.join(tempDir, "monolith.ts");
      await fs.writeFile(
        sourceFile,
        `export function processOrder(order: any) {
  // Validate order
  if (!order.items || order.items.length === 0) {
    throw new Error("Order must have items");
  }
  if (!order.customerId) {
    throw new Error("Order must have customerId");
  }

  // Calculate total
  let subtotal = 0;
  for (const item of order.items) {
    subtotal += item.price * item.quantity;
  }
  const tax = subtotal * 0.1;
  const total = subtotal + tax;

  // Format receipt
  let receipt = "ORDER RECEIPT\\n";
  receipt += "============\\n";
  for (const item of order.items) {
    receipt += item.name + " x" + item.quantity + " = $" + (item.price * item.quantity) + "\\n";
  }
  receipt += "Subtotal: $" + subtotal + "\\n";
  receipt += "Tax: $" + tax + "\\n";
  receipt += "Total: $" + total;

  return { total, receipt };
}
`
      );

      const { messages } = await runAgent(
        `Read the file at ${sourceFile} and refactor it by extracting the three logical sections into separate functions:
1. validateOrder(order) - throws on invalid order
2. calculateOrderTotal(items) - returns { subtotal, tax, total }
3. formatReceipt(items, subtotal, tax, total) - returns formatted receipt string

Then update processOrder to use these helper functions. Keep everything in the same file.`,
        {
          allowedTools: ["Read", "Edit", "Write"],
          permissionMode: "bypassPermissions",
          cwd: tempDir,
          maxTurns: 12,
        }
      );

      expect(wasSuccessful(messages)).toBe(true);

      const refactoredContent = await fs.readFile(sourceFile, "utf-8");
      expect(refactoredContent).toContain("validateOrder");
      expect(refactoredContent).toContain("calculateOrderTotal");
      expect(refactoredContent).toContain("formatReceipt");
      // processOrder should still exist and use helpers
      expect(refactoredContent).toContain("processOrder");
    }, 180000);

    it("should create an HTML file with embedded CSS and JavaScript", async () => {
      const htmlFile = path.join(tempDir, "index.html");

      const { messages } = await runAgent(
        `Create a complete HTML file at ${htmlFile} that includes:
1. A proper HTML5 doctype and structure
2. Embedded CSS in a <style> tag that styles a centered card with shadow
3. Embedded JavaScript in a <script> tag that toggles the card's background color when clicked
4. The card should contain a heading "Click Me" and some placeholder text`,
        {
          allowedTools: ["Write"],
          permissionMode: "bypassPermissions",
          cwd: tempDir,
          maxTurns: 8,
        }
      );

      expect(wasSuccessful(messages)).toBe(true);

      const htmlContent = await fs.readFile(htmlFile, "utf-8");
      expect(htmlContent).toContain("<!DOCTYPE html>");
      expect(htmlContent).toContain("<style>");
      expect(htmlContent).toContain("<script>");
      expect(htmlContent.toLowerCase()).toContain("click");
    }, 180000);

    it("should read a log file and generate an analysis report", async () => {
      const logFile = path.join(tempDir, "app.log");
      await fs.writeFile(
        logFile,
        `2024-01-15 10:00:00 INFO Application started
2024-01-15 10:00:05 INFO User login: user123
2024-01-15 10:00:10 ERROR Database connection failed
2024-01-15 10:00:15 WARN Retrying database connection
2024-01-15 10:00:20 INFO Database connected
2024-01-15 10:00:25 INFO User login: user456
2024-01-15 10:00:30 ERROR Payment processing failed for order 789
2024-01-15 10:00:35 INFO User logout: user123
2024-01-15 10:00:40 WARN Memory usage high: 85%
2024-01-15 10:00:45 ERROR User authentication failed: user999
2024-01-15 10:00:50 INFO User login: user789
`
      );

      const reportFile = path.join(tempDir, "log-analysis.md");

      const { messages } = await runAgent(
        `Read the log file at ${logFile} and analyze it. Then use the Write tool to create a markdown report file at ${reportFile}.

The report MUST include:
1. Count of each log level (there are 6 INFO, 2 WARN, 3 ERROR entries)
2. List of the 3 ERROR messages
3. Summary of user logins/logouts

IMPORTANT: You must use the Write tool to save the report to ${reportFile}. Do not just output the analysis - write it to the file.`,
        {
          allowedTools: ["Read", "Write"],
          permissionMode: "bypassPermissions",
          cwd: tempDir,
          maxTurns: 10,
        }
      );

      expect(wasSuccessful(messages)).toBe(true);

      // Verify the file was created
      const fileExists = await fs.access(reportFile).then(() => true).catch(() => false);
      expect(fileExists).toBe(true);

      const reportContent = await fs.readFile(reportFile, "utf-8");
      // Should have log level info
      expect(reportContent.toLowerCase()).toMatch(/info|error|warn/);
      // Should mention at least one error
      expect(
        reportContent.toLowerCase().includes("database") ||
        reportContent.toLowerCase().includes("payment") ||
        reportContent.toLowerCase().includes("authentication") ||
        reportContent.toLowerCase().includes("error")
      ).toBe(true);
    }, 180000);
  });
});
